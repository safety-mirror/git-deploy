#!/bin/bash

# Uses GPG2 to generate ciphertexts that can be stored in etcd
# Each environment (i.e. staging, production) has a signing key that should never be exported
# Each application (i.e. staging-redis, staging-nginx) has a unique encryption key


KEY_SIZE=4096

ENVIRONMENT=$1
APP=$2
KEY=$3
VALUE=$4

if [ -z "${ENVIRONMENT}" -o -z "${APP}" -o -z "${KEY}" ]; then
	echo "Usage: $0 environment app key [value]"
	echo '  if value is not provided it will be read from stdin'
	exit 1
fi

# Verify environment (git repo) and application (dir within repo) exist:
if [ ! -d /git/${ENVIRONMENT} ]; then
	echo "Repo ${ENVIRONMENT} not found"
	exit 1
fi
git --git-dir=/git/${ENVIRONMENT}/.git archive -o /dev/null master apps/${APP} 2> /dev/null
if [ $? -ne 0 ]; then
	echo "App ${APP} not found in ${ENVIRONMENT}"
	exit 1
fi

ensure_key() {
	local key_name=$1
	local key_usage=${2-default}
	{
		flock -x 200
		EXISTING_KEYS=$(gpg --list-secret-keys ${key_name} >/dev/null 2>&1 )
		if [ $? -ne 0 ]; then
			generate_key ${key_name} ${key_usage}
			EXISTING_KEYS=$(gpg --list-secret-keys ${key_name} >/dev/null 2>&1)
		fi
	} 200>keygen
}

generate_key() {
	local key_name=$1
	local key_usage=$2
	# Reference: https://www.gnupg.org/documentation/manuals/gnupg/Unattended-GPG-key-generation.html
	echo "
%no-protection
Key-Type: RSA
Key-Length: ${KEY_SIZE}
Key-Usage: ${key_usage}
Subkey-Type: RSA
Subkey-Length: ${KEY_SIZE}
Subkey-Usage: ${key_usage}
Name-Real: ${key_name}
Expire-Date: 0
%commit
" | gpg2 --batch --gen-key - >/dev/null 2>&1

	# Fire duplicity, but keep stdout clean
	git-shell-commands/backup >/dev/null
}

to_ciphertext() {
	# Output fully trimmed GPG block: no header/trailer, version or whitespace
	cat <&0 | \
		gpg --encrypt --armor --no-version --sign --local-user ${ENV_NAME} --recipient ${APP_NAME} | \
		grep '^[^-]' | \
		tr -d '\n'
}

# Generate keys:
ENV_NAME=env-${ENVIRONMENT}
APP_NAME=app-${ENVIRONMENT}-${APP}
ensure_key ${ENV_NAME} sign
ensure_key ${APP_NAME} encrypt


if [ -n "$VALUE" ]; then
	# Value specified as argument
	{
		echo KEY=${KEY};
		echo ${VALUE}
	} | to_ciphertext
else
	# Value read from stdin
	{
		echo KEY=${KEY};
		cat <&0
	} | to_ciphertext
fi

